<!DOCTYPE html>
<html lang="zh">
<head>
	<meta charset="UTF-8" />
	<title>Document</title>
</head>
<body>
      ----Php后边为什么有的带？有的不带？
      get 只要走url传入数据给后端那么必须加？，规定。
      post 传输通过send 不用加？

      user后面要加=    K值=val值 & k值=val值
      字段与字段中间用&分割

      不会的就去搜，去找答案


XML  ---- 是一种数据类型
      ajax中获取xml数据:
          const data = ajax.responseXML;


      缓存，有浏览器缓存和

      浏览器缓存：
            通过浏览器URL访问的地址，如果每次访问就会
            把这个地址给缓存下来，以便下次访问直接就走
            缓存。下一次访问同一个地址的时候不在进行
            HTTP请求了。大大减少了服务器的压力。

      有些时候后端改的东西因为有缓存机制，所以再次刷新
      页面的时候，依然显示之前的内容。

      解决：
          只要不是同一个地址就OK；

      低版本不支持onload，IE9以下的浏览器是不会触发onload的。
			但是在所有的浏览器都支持onreadystatechange，作用和onload一样的。

			当服务器进行响应的时候，每完成一个步骤就会触发这个事件，
			从发送到服务器处理完成一共有5个步骤，每个步骤都是用数字来表示的。
			0-4，   ajax.readyState
			只不过0是监控不到的。
			不管它进行到几，只要到了数字4，就说明服务器接收并响应了完成了。

			XMLHTTPRequest  对象的3个重要属性：

				1.监听事件
							onreadystatechange

							事件中判断执行步骤到4，onload不兼容低版本
				2.执行的步骤
							ajax.readyState
							if(ajax.readyState == 4){
									判断状态码
							}
				3.状态码
							ajax.status
							if(ajax.status >= 200 && ajax.status <=207 || ajax.status == 304){
										//成功
							}else{
										//失败
							}

			onreadystatechange放在send的前面和后面的区别：
			能多监听一步而已，其实能不能监听到意义不大。因为，只有数字4才算请求完毕




		  ajax.status 就是专门查看HTTP状态码值的。

      状态码：
          1开头消息;
          2开头成功;
          3开头重定向;
          4开头请求出错;
          5开头服务器问题;
          6开头服务器问题;


      回车
      去除回车
      function ClearBr(key){
        key = key.replace(/[\r\n]/g,"");
        return key;
      }

      优化方案：将数据埋在页面中，不用请求接口;

			同步：
				代码执行是一句一句的来，如果一句代码没有执行完就不会执行下段代码，
				下一句代码始终要等待上一句代码执行完成次才会执行。

			异步：
				代码执行是一句一句的来，如果上一句代码没有执行完可以执行另一段代码的
				不用等待上一句代码执行完成就能执行。


			数据不用ajax请求，直接堆到页面。
</body>
</html>
